---
title: "Multinomial CI Prediction for 2020 Election"
author: "Shanghao Zhong"
date: "2020-11-06"
output:
  pdf_document: default
  html_notebook: default
---

Load package
```{r}
library(jsonlite)
library(lubridate)
library(MultinomialCI)
library(dplyr)
```

You also need to load the data. You should have the `all.state.dataset` ready when data is load correctly.
```{r}
load("MultinomialCIProject2020.RData")
all.state.dataset <- get('all.state.dataset')
summary(all.state.dataset)
```


## Predifine function

The script concerns about the probability of a vote cast for a specific candidate.
Assuming the votes follow a multinomial distribution, 
it uses the `MultinomialCI` package to calculate the confidence interval
of the probability for each candidate.

```{r}
#' Calculate county level multinomial c.i.
#'
#' @param df a data frame with vote counts. 
#'           row.name is county name, 
#'           and each column is the number of votes for each candidate.
#' @param alpha The significance level for the confidence intervals. 
#'              Must be a real number in the interval [0, 1]
#' @return a data frame of confidence intervals for each candidate
#' @export
CI.by.county <- function(df, alpha) {
  df <- filter(df, df[[1]] > 0)
  candidate.names <- names(df)
  county <- row.names(df)
  mat <- t(apply(df, 1, as.numeric))
  
  CI.per.county <- function(vec) {
    CI.per.county <- c(multinomialCI(pmax(vec, 0), alpha))
  }
  cols <- apply(expand.grid(candidate.names, c('low', 'high')), 1, paste, collapse='.')
  all.ci <- t(apply(mat, 1, CI.per.county))
  
  output <- data.frame(all.ci, row.names = county)
  colnames(output) <- cols
  
  return(output)
}
```

With the probability of a vote cast for a candidate, the final projection is done by
$np \pm z\cdot \sqrt{n\cdot p\cdot (1-p)}$, where $p$ is the probability of a candidate
winning a vote, $n$ is the expected remaining vote according to NYT.

```{r}
#' Calculate prediction interval of the remaining votes given the 
#' probability.
#'
#' @param remaining A scalar or vector containing the remaining votes in the 
#'                  county.
#' @param prob A scalar or vector containing the probability of votes going to 
#'             the candidate in the county.
#' @param alpha confidence level
#'
#' @return a length 2 vector, first is the lower bound and the second is the 
#'         upper.
#' @export
p.interval <- function(remaining, prob, alpha=0.95) {
  lo <- remaining*prob + qnorm((1-alpha)/2)*sqrt(remaining*prob*(1-prob))
  hi <- remaining*prob - qnorm((1-alpha)/2)*sqrt(remaining*prob*(1-prob))
  return(c(lo = sum(lo, na.rm = TRUE), hi = sum(hi, na.rm = TRUE)))
}
```


```{r}
#' Helper function to convert UTC time string to EST
#'
#' @param timestring string representation of time, NYT's time in ISO format
#'
#' @return a POSIXct object in EST
#' @export
#'
#' @examples to_EST('2020-11-07T01:46:10Z')
to.EST <- function(timestring) {
  with_tz(parse_date_time(timestring, 'ymd HMS'), 'EST')
}
```

More helper functions to pull data from NYT.

- `collect.data(dataset, state)` pulls data from NYT.
- `get.state.data(dataset, state, index)` gets historic data of a state.
- `load.state.data(state.data, names)` saves state data into global environment.

```{r}
#' Collect data from NYT of the given state and return the updated dataset.
#'
#' @param dataset The dataset that store all previously pull data. 
#'                It should be a list of all tracked states, 
#'                  each is another list that contains historical snapshot.
#' @param state What state we want to get the data for. 
#'              White spaces should be replaced by `-`.
#'              For example, New York should be `new-york`,
#'                Pennsylvania should be `pennsylvania`, and
#'                D.C. should be `district-of-columbia`.
#'
#' @return The updated dataset, in which the new data is appended at the end of 
#'           its state list.
#' @export
#'
#' @examples 
#' # this will read arizona data, update the dataset, and assign it back.
#' all.state.dataset %>% collect.data('arizona') -> all.state.dataset
collect.data <- function(dataset, state) {
  nyt.api <- paste(
    'https://static01.nyt.com/elections-assets/2020/data/api/2020-11-03/race-page/', 
    state, 
    '/president.json',
    sep = '')
  
  results <- fromJSON(nyt.api)
  current.time <- max(results$data$races$counties[[1]]$last_updated)
  
  if (!state %in% names(dataset)) {
    update.type <- "New state"
    dataset[[state]] <- list()
    dataset[[state]][[current.time]] <- results$data$races$counties[[1]]
  } else { # if the state has been track, see if this one is new update
    previous.time <- max(last(dataset[[state]])$last_updated)
    if (current.time == previous.time) {
      update.type <- "No update"
    } else {
      update.type <- "New update"
      dataset[[state]][[current.time]] <- results$data$races$counties[[1]]
    }
  }
  
  cat(paste(state, ":", update.type),
      paste("Update time:", to.EST(current.time)),
      paste("Current margin for Biden:",
            sum(last(dataset[[state]])$results$bidenj) 
            - sum(last(dataset[[state]])$results$trumpd)),
      sep='\n')
  
  return(dataset)
}


#' Get a state's data of a historic snapshot.
#'
#' @param dataset The dataset that stores all state's data
#' @param state The state of which you are getting the data
#' @param index The index of the historical snapshot of this state. 
#'              The latest snapshot will be pulled by default.
#'
#' @return 
#' a list containing 3 elements: 
#' - `state.details`: all the details of this snapshot, by county,
#' - `all.votes`: all vote counts of each candidate, by county, and
#' - `mail.votes`: mail vote counts of each candidate, by county.
#'
#' @export
#'
#' @examples
#' all.state.dataset %>% get.state.data('arizona')
get.state.data <- function(dataset, state, index = NULL) {
  state.data <- dataset[[state]]
  if (is.null(index)) {
    index <- length(state.data)
  }
  state.details <- state.data[[index]]
  
  cat('Get state data for', state, 
      paste('(updated at: ', to.EST(max(state.details$last_updated)), ').\n', 
            sep = ''))
  
  return(list(
    state.details = state.details,
    all.votes = data.frame(state.details$results, 
                            row.names = state.details$name),
    mail.votes = data.frame(state.details$results_absentee, 
                             row.names = state.details$name)
  ))
}

#' Load state data into global environment.
#'
#' @param state.data The state data, usually the return from `get.state.data`
#' @param names The global variable names to store `state.details`, `all.votes`, 
#'                and `mail.votes` from `state.data`
#'
#' @return NULL
#' @export
#'
#' @examples 
#' # load latest data
#' get.state.data(all.state.dataset, current.state.name) %>% load.state.data()
#' # load first snapshot
#' get.state.data(all.state.dataset, current.state.name, 1) %>%
#'   load.state.data(c('old.state.details', 'old.all.votes', 'old.mail.votes'))
load.state.data <- function(state.data, names = c('state.details', 
                                                  'all.votes', 
                                                  'mail.votes')) {
  if(length(names) != 3 & typeof(names) != 'character') {
    stop('names should be a character vector with 3 elements.')
  }
  assign(names[1], state.data$state.details, envir = .GlobalEnv, inherits = TRUE)
  assign(names[2], state.data$all.votes, envir = .GlobalEnv, inherits = TRUE)
  assign(names[3], state.data$mail.votes, envir = .GlobalEnv, inherits = TRUE)
  cat('State data are loaded in: ', 
      paste(names, collapse = ', '), 
      '.\n', 
      sep = '')
}
```

## Pull data
Pull new data from a state from NYT's API.
`current.state.name` needs to be the fully spelled name in lowercase in which spaces is replaced by `-`.
For example, New York will be `new-york`; Pennsylvania will be `pennsylvania`, and D.C. will be `district-of-columbia`.
```{r}
current.state.name <- 'arizona'
all.state.dataset %>% collect.data(current.state.name) -> all.state.dataset
all.state.dataset %>% get.state.data(current.state.name) %>% load.state.data()
```

See the number of snapshots saved
```{r}
sapply(all.state.dataset, length)
```

See the time at which snapshots were taken (in EST)
```{r}
to.EST(names(all.state.dataset[[current.state.name]]))
```


## Estimate the probability for each candidate

You can change `using` to update how you want to estimate the probability.
Unhide one of them and hide to other to use.

first option: 

- Use the difference between old data and new data
- Best for predicting the most recent trend
- Doesn't work if the difference between old data and new data is small or non-representative

second option: 

- Use the mail.votes to predict old data and new data 
- Work the best if the mail votes is homogeneous throughout different time
- Doesn't work But the demographics within mail data can change over time

When `using` is incomplete, the probability of each candidate will based on `all.votes`


```{r}
# first option
using <- data.frame(
  data.matrix(get.state.data(all.state.dataset, current.state.name)$all.votes)
  - data.matrix(get.state.data(all.state.dataset, current.state.name, 1)$all.votes),
  row.names = get.state.data(all.state.dataset, current.state.name)$state.details$name)

# second option
# using <- get.state.data(all.state.dataset, current.state.name)$mail.votes

remaining <- data.frame(exp.remaining = pmax(0, state.details$tot_exp_vote - rowSums(data.matrix(all.votes))), 
                        row.names = state.details$name)
ci.mail <- merge(remaining, CI.by.county(using, 0.95), by=0)
ci.other <- merge(remaining, CI.by.county(all.votes, 0.95), by=0)
ci.other <- ci.other[ci.other$Row.names %in% 
                       setdiff(ci.other$Row.names, ci.mail$Row.names), ]
est <- rbind(ci.mail, ci.other)
rm(remaining)

est <- est[order(est$Row.names), ]
rownames(est) <- est$Row.names
est$Row.names <- NULL
est[est$exp.remaining > 0, ]
```


## Estimate the final range

With the lower and upper bound of Biden's and Trump's probability in a county,
we use both probability to calculate the CI. 
The lower end of the CI from the low probability is a candidate's lower bound,
while the upper end of the CI from the high probility is a candidate's upper bound.
We then see the margin using Biden's lower bound $-$ Trump's upper bound, 
and using Biden's upper bound $-$ Trump's lower bound, to calculate the final projection interval.

```{r}
future.lo <- p.interval(est$exp.remaining, est$bidenj.low)[1] - p.interval(est$exp.remaining, est$trumpd.high)[2]
future.hi <- p.interval(est$exp.remaining, est$bidenj.high)[2] - p.interval(est$exp.remaining, est$trumpd.low)[1]
current.diff <- sum(all.votes$bidenj) - sum(all.votes$trumpd)
current.diff + c(future.lo, future.hi)
```


Saving the data
```{r}
save.image("MultinomialCIProject2020.RData")
```

